package com.sanjay900.PortalStick;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

import org.bukkit.Bukkit;
import org.bukkit.DyeColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.Sign;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.FallingBlock;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityChangeBlockEvent;
import org.bukkit.event.entity.ItemDespawnEvent;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.player.PlayerAnimationEvent;
import org.bukkit.event.player.PlayerChangedWorldEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerPickupItemEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.util.BlockIterator;

import com.bergerkiller.bukkit.common.events.EntityRemoveEvent;
import com.matejdro.bukkit.portalstick.PortalStick;

import de.ase34.flyingblocksapi.FlyingBlock;

public class EventListener implements Listener {

	public ArrayList<Block> wire = new ArrayList<Block>();
	public HashMap<Player, Block> buttonsToPlayer = new HashMap<>();
	public HashMap<Block, Block> buttons = new HashMap<>();
	public HashMap<Block, FallingBlock> cubes = new HashMap<Block, FallingBlock>();
	public HashMap<Block, Player> cubesPlayer = new HashMap<Block, Player>();
	public HashMap<Block, Block> cubesFallen = new HashMap<Block, Block>();
	public HashMap<Block, ItemStack> cubesPlayerItem = new HashMap<Block, ItemStack>();
	public PortalStick plugin;
	public HashMap<Block, Block> cubesign = new HashMap<>();
	public HashMap<BukkitTask, Block> hatches = new HashMap<>();
	public HashMap<Block, FlyingBlock> FlyingBlocks = new HashMap<>();;

	public EventListener(PortalStick portalStick) {

		portalStick.getServer().getPluginManager()
				.registerEvents(this, portalStick);
		plugin = portalStick;
	}
	public void changeBtn(Block under, boolean on) {
		if (on)  {
		under.getRelative(BlockFace.EAST).getRelative(BlockFace.EAST)
				.setType(Material.EMERALD_BLOCK);
		under.getRelative(BlockFace.WEST).getRelative(BlockFace.WEST)
				.setType(Material.EMERALD_BLOCK);
		under.getRelative(BlockFace.NORTH).getRelative(BlockFace.NORTH)
				.setType(Material.EMERALD_BLOCK);
		under.getRelative(BlockFace.SOUTH).getRelative(BlockFace.SOUTH)
				.setType(Material.EMERALD_BLOCK);
		} else {
			under.getRelative(BlockFace.EAST).getRelative(BlockFace.EAST)
					.setType(Material.REDSTONE_BLOCK);
			under.getRelative(BlockFace.WEST).getRelative(BlockFace.WEST)
					.setType(Material.REDSTONE_BLOCK);
			under.getRelative(BlockFace.NORTH).getRelative(BlockFace.NORTH)
					.setType(Material.REDSTONE_BLOCK);
			under.getRelative(BlockFace.SOUTH).getRelative(BlockFace.SOUTH)
					.setType(Material.REDSTONE_BLOCK);
		}
	}
	@SuppressWarnings("deprecation")
	@EventHandler
	public void onEntityDeath(final EntityRemoveEvent event) {
		if (event.getEntity().getType() == EntityType.FALLING_BLOCK) {
			final FallingBlock fb = ((FallingBlock) event.getEntity());
			Bukkit.getScheduler().scheduleSyncDelayedTask(plugin,
					new Runnable() {
						@Override
						public void run() {
							if (cubes.containsValue((FallingBlock) event
									.getEntity())) {
								for (Entry<Block, FallingBlock> entry : cubes
										.entrySet()) {
									if (((FallingBlock) event.getEntity())
											.equals(entry.getValue())) {
										FallingBlock f = entry
												.getKey()
												.getWorld()
												.spawnFallingBlock(
														fb.getLocation(),
														fb.getMaterial()
																.getId(),
														(byte) fb
																.getBlockData());
										f.setDropItem(false);
										f.setVelocity(event.getEntity()
												.getVelocity());
										event.getEntity().remove();
										cubes.remove(entry.getKey());
										cubes.put(entry.getKey(), f);

									}
								}
							}
						}
					}, 1L);

		}

	}

	@EventHandler
	public void onPlayerLogin(final PlayerJoinEvent event) {
		Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, new Runnable() {
			@Override
			public void run() {

			}
		}, 3L);
	}

	public static Entity getTarget(final Player player) {

		BlockIterator iterator = new BlockIterator(player.getWorld(), player
				.getLocation().toVector(), player.getEyeLocation()
				.getDirection(), 0, 100);
		Entity target = null;
		while (iterator.hasNext()) {
			Block item = iterator.next();
			for (Entity entity : player.getNearbyEntities(100, 100, 100)) {
				int acc = 2;
				for (int x = -acc; x < acc; x++)
					for (int z = -acc; z < acc; z++)
						for (int y = -acc; y < acc; y++)
							if (entity.getLocation().getBlock()
									.getRelative(x, y, z).equals(item)) {
								return target = entity;
							}
			}
		}
		return target;
	}

	@SuppressWarnings("deprecation")
	@EventHandler
	public void onPlayerAnimation(PlayerAnimationEvent event) {
		for (Entry<Block, FlyingBlock> entry : FlyingBlocks.entrySet()) {
			Entity en = getTarget(event.getPlayer());

			if (en == entry.getValue()) {
				FlyingBlocks.remove(entry.getKey());
				cubesPlayer.put(entry.getKey(), event.getPlayer());
				cubesPlayerItem.put(entry.getKey(), new ItemStack(entry
						.getValue().getMaterial(), 1, entry.getValue()
						.getMaterialData()));
				event.getPlayer()
						.getInventory()
						.addItem(
								new ItemStack(entry.getValue().getMaterial(),
										1, entry.getValue().getMaterialData()));
				doInventoryUpdate(event.getPlayer(), plugin);
				entry.getValue().remove();

			}
		}

		for (FallingBlock e : cubes.values()) {
			Entity en = getTarget(event.getPlayer());
			if (en == e) {

				for (Entry<Block, FallingBlock> entry : cubes.entrySet()) {
					if (en.equals(entry.getValue())) {
						cubes.remove(entry.getKey());
						cubesPlayer.put(entry.getKey(), event.getPlayer());
						FallingBlock b = (FallingBlock) en;
						cubesPlayerItem.put(
								entry.getKey(),
								new ItemStack(b.getMaterial(), 1, b
										.getBlockData()));
						event.getPlayer()
								.getInventory()
								.addItem(
										new ItemStack(b.getMaterial(), 1, b
												.getBlockData()));
						doInventoryUpdate(event.getPlayer(), plugin);
						en.remove();
						break;

					}
				}

			}

		}

	}

	@EventHandler
	public void onPlayerLeave(PlayerQuitEvent event) {
		Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, new Runnable() {
			@Override
			public void run() {

			}
		}, 3L);

	}

	/**
	 * Removes a item from a inventory
	 * 
	 * @param inventory
	 *            The inventory to remove from.
	 * @param mat
	 *            The material to remove .
	 * @param amount
	 *            The amount to remove.
	 * @param damage
	 *            The data value or -1 if this does not matter.
	 */
	@SuppressWarnings("deprecation")
	public static void remove(Inventory inv, Material type, int amount,
			short damage) {
		ItemStack[] items = inv.getContents();
		for (int i = 0; i < items.length; i++) {
			ItemStack is = items[i];
			if (is != null && is.getType() == type
					&& is.getData().getData() == damage) {
				int newamount = is.getAmount() - amount;
				if (newamount > 0) {
					is.setAmount(newamount);
					break;
				} else {
					items[i] = new ItemStack(Material.AIR);
					amount = -newamount;
					if (amount == 0)
						break;
				}
			}
		}
		inv.setContents(items);

	}

	/**
	 * Checks weather the inventory contains a item or not.
	 * 
	 * @param inventory
	 *            The inventory to check..
	 * @param mat
	 *            The material to check .
	 * @param amount
	 *            The amount to check.
	 * @param damage
	 *            The data value or -1 if this does not matter.
	 * @return The amount of items the player has not. If this return 0 then the
	 *         check was successfull.
	 */
	public static int contains(Inventory inventory, Material mat, int amount,
			short damage) {
		ItemStack[] contents = inventory.getContents();
		int searchAmount = 0;
		for (ItemStack item : contents) {

			if (item == null || !item.getType().equals(mat)) {
				continue;
			}

			if (damage != -1 && item.getDurability() == damage) {
				continue;
			}

			searchAmount += item.getAmount();
		}
		return searchAmount - amount;
	}

	@EventHandler
	public void onWorldChange(PlayerChangedWorldEvent event) {

	}

	@SuppressWarnings("deprecation")
	@EventHandler
	public void onPlayerMove(final PlayerMoveEvent event) {
		Block blockUnder = event.getTo().getBlock().getRelative(BlockFace.DOWN);
		BlockFace[] blockfaces = new BlockFace[] { BlockFace.WEST,
				BlockFace.NORTH_WEST, BlockFace.NORTH, BlockFace.NORTH_EAST,
				BlockFace.EAST, BlockFace.SOUTH, BlockFace.SOUTH_WEST,
				BlockFace.SOUTH_EAST };
		if (blockUnder.getType() == Material.WOOL) {
			Block middle = blockUnder;
			boolean error = false;
			// red wool - find closest black and check around
			if (blockUnder.getData() == (byte) 14) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}
			}
			// middle - already have relative
			else if (blockUnder.getData() == (byte) 15) {

				if (blockUnder.getRelative(BlockFace.NORTH).getType() == Material.WOOL
						&& blockUnder.getRelative(BlockFace.NORTH).getData() == (byte) 14) {
					middle = blockUnder;
				}

			} else
			// lime
			if (blockUnder.getData() == (byte) 5) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}
			} else {
				error = true;
			}

			for (BlockFace f : blockfaces) {
				Block rel = middle.getRelative(f);
				if (rel.getType() == Material.WOOL
						&& (rel.getData() == (byte) 14 || rel.getData() == (byte) 5)) {

				} else {
					error = true;
				}
			}
			if (!error && !buttonsToPlayer.containsValue(middle)
					&& !buttons.containsKey(middle)) {
				buttonsToPlayer.put(event.getPlayer(), middle);
				
				for (BlockFace f : blockfaces) {
					middle.getRelative(f).setType(Material.WOOL);
					middle.getRelative(f).setData((byte) 5);

				}
				Block under = middle.getRelative(BlockFace.DOWN);
				changeBtn(under, !buttons.containsKey(middle));
				buttons.put(middle, null);
			}
		} else if (buttonsToPlayer.containsKey(event.getPlayer())) {
			Block middle = buttonsToPlayer.get(event.getPlayer());
			for (BlockFace f : blockfaces) {
				middle.getRelative(f).setType(Material.WOOL);
				middle.getRelative(f).setData((byte) 14);
			}
			Block under = middle.getRelative(BlockFace.DOWN);
			changeBtn(under, !buttons.containsKey(middle));
			buttonsToPlayer.remove(event.getPlayer());
			buttons.remove(middle);
		}

	}





	@SuppressWarnings("deprecation")
	@EventHandler
	public void death(PlayerDeathEvent event) {
		if (cubesPlayer.containsValue(event.getEntity())) {

			for (Entry<Block, Player> entry : cubesPlayer.entrySet()) {
				if (event.getEntity().equals(entry.getValue())) {
					if (cubesign.get(entry.getKey()).isBlockPowered()
							|| cubesign.get(entry.getKey())
									.isBlockIndirectlyPowered()) {

						FallingBlock f = entry
								.getKey()
								.getWorld()
								.spawnFallingBlock(
										entry.getKey().getLocation(),
										cubesPlayerItem.get(entry.getKey())
												.getTypeId(),
										(byte) cubesPlayerItem
												.get(entry.getKey()).getData()
												.getData());
						f.setDropItem(false);
						event.getEntity().sendMessage("test");
						ArrayList<ItemStack> remove = new ArrayList<>();
						for (ItemStack drop : event.getDrops()) {
							// You can add a check for item types here. Like
							// if(drop.getType() == Material.TNT) ...
							if (drop.getType() == cubesPlayerItem.get(
									entry.getKey()).getType()
									&& drop.getData().getData() == cubesPlayerItem
											.get(entry.getKey()).getData()
											.getData()) {
								remove.add(drop);
								break;
							}

						}

						for (ItemStack is : remove) {
							event.getDrops().remove(is);
						}
						cubesPlayer.remove(entry.getKey());
						cubesPlayerItem.remove(entry.getKey());

						cubes.put(entry.getKey(), f);
					}
				}
			}

			return;
		}
	}

	@SuppressWarnings("deprecation")
	@EventHandler
	public void drop(final PlayerDropItemEvent event) {
		if (cubesPlayer.containsValue(event.getPlayer())) {

			for (Entry<Block, Player> entry : cubesPlayer.entrySet()) {
				if (event.getPlayer().equals(entry.getValue())) {
					if (cubesPlayerItem.get(entry.getKey()).getType() == event
							.getItemDrop().getItemStack().getType()) {

						FallingBlock f = entry
								.getKey()
								.getWorld()
								.spawnFallingBlock(
										event.getPlayer().getEyeLocation(),
										event.getItemDrop().getItemStack()
												.getTypeId(),
										event.getItemDrop().getItemStack()
												.getData().getData());
						f.setDropItem(false);
						f.setVelocity(event.getPlayer().getLocation()
								.getDirection().multiply(1));
						event.setCancelled(true);

						Bukkit.getScheduler().scheduleSyncDelayedTask(plugin,
								new Runnable() {
									@Override
									public void run() {
										if (event.getPlayer().getItemInHand()
												.getAmount() - 1 > 1) {
											ItemStack hand = event.getPlayer()
													.getItemInHand();
											hand.setAmount(event.getPlayer()
													.getItemInHand()
													.getAmount() - 1);
											event.getPlayer().setItemInHand(
													hand);

										} else {
											event.getPlayer().setItemInHand(
													null);
										}
									}
								});
						cubes.put(entry.getKey(), f);
						cubesPlayer.remove(entry.getKey());

					}

					return;
				}
			}
		}

	}

	@SuppressWarnings("deprecation")
	@EventHandler
	public void blockBreak(PlayerInteractEvent event) {

		if (event.getAction() != Action.LEFT_CLICK_BLOCK
				|| cubesPlayer.containsValue(event.getPlayer()))
			return;
		if (cubesFallen.containsValue(event.getClickedBlock())) {
			ItemStack stack = new ItemStack(event.getClickedBlock().getType(),
					1, event.getClickedBlock().getData());
			for (Entry<Block, Block> entry : cubesFallen.entrySet()) {
				if (event.getClickedBlock().equals(entry.getValue())) {

					event.setCancelled(true);

					event.getPlayer().getInventory().addItem(stack);
					event.getPlayer().updateInventory();
					cubesPlayer.put(entry.getKey(), event.getPlayer());

					cubesPlayerItem.put(entry.getKey(), stack);

					event.getClickedBlock().setType(Material.AIR);
					cubesFallen.remove(entry.getKey());

				}
			}

		}
		Block blockUnder = event.getClickedBlock().getRelative(BlockFace.DOWN);
		BlockFace[] blockfaces = new BlockFace[] { BlockFace.WEST,
				BlockFace.NORTH_WEST, BlockFace.NORTH, BlockFace.NORTH_EAST,
				BlockFace.EAST, BlockFace.SOUTH, BlockFace.SOUTH_WEST,
				BlockFace.SOUTH_EAST };

		if (blockUnder.getType() == Material.WOOL) {
			Block middle = blockUnder;
			// red wool - find closest black and check around
			if (blockUnder.getData() == (byte) 14) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}

			}
			// middle - already have relative
			if (blockUnder.getData() == (byte) 15) {

				if (blockUnder.getRelative(BlockFace.NORTH).getType() == Material.WOOL
						&& blockUnder.getRelative(BlockFace.NORTH).getData() == (byte) 5) {
					middle = blockUnder;
				} else if (blockUnder.getRelative(BlockFace.UP)
						.getRelative(BlockFace.NORTH).getType() == Material.WOOL
						&& blockUnder.getRelative(BlockFace.UP)
								.getRelative(BlockFace.NORTH).getData() == (byte) 5) {
					{
						middle = blockUnder.getRelative(BlockFace.UP);

					}

				}
			}
			// lime
			if (blockUnder.getData() == (byte) 5) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}

			}

			boolean error = false;
			for (BlockFace f : blockfaces) {
				if (!(middle.getRelative(f).getType() == Material.WOOL)) {
					error = true;
				}
			}
			if (!error && buttons.containsKey(middle)) {

				for (BlockFace f : blockfaces) {
					middle.getRelative(f).setType(Material.WOOL);
					middle.getRelative(f).setData((byte) 14);

				}
				Block under = middle.getRelative(BlockFace.DOWN);
				changeBtn(under, !buttons.containsKey(middle));
				buttons.remove(middle);
			} else {
				// vertical in wall block
				Block block = event.getClickedBlock();
				if (event.getClickedBlock().getRelative(BlockFace.DOWN)
						.getType() == Material.WOOL
						&& event.getClickedBlock().getRelative(BlockFace.UP)
								.getType() == Material.WOOL) {
					if (event.getClickedBlock().getRelative(BlockFace.WEST)
							.getType() == Material.WOOL
							&& event.getClickedBlock()
									.getRelative(BlockFace.EAST).getType() == Material.WOOL) {
						Block[] blocks = new Block[] {
								block.getRelative(BlockFace.UP),
								block.getRelative(BlockFace.DOWN),
								block.getRelative(BlockFace.WEST),
								block.getRelative(BlockFace.EAST),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.WEST),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.EAST),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.WEST),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.EAST) };
						boolean error2 = false;
						for (Block block2 : blocks) {
							if (!(block2.getType() == Material.WOOL && (block2
									.getData() == (byte) 5 || block2.getData() == (byte) 14))) {
								error2 = true;
							}
						}
						BlockFace face = BlockFace.SELF;
						if (block.getRelative(BlockFace.NORTH).getType() == Material.WOOL) {
							face = BlockFace.NORTH;
						}
						if (block.getRelative(BlockFace.SOUTH).getType() == Material.WOOL) {
							face = BlockFace.SOUTH;
						}
						if (!error2 && buttons.containsKey(block)
								&& face != BlockFace.SELF) {

							buttons.remove(block);
							for (Block block2 : blocks) {
								block2.setType(Material.WOOL);
								block2.setData((byte) 14);

							}
							for (Block block2 : blocks) {
								block2.getRelative(face).setType(
										Material.EMERALD_BLOCK);

							}

						} else if (!event.getPlayer().hasPermission(
								"portal.place")) {
							event.setCancelled(true);
						}

					} else if (event.getClickedBlock()
							.getRelative(BlockFace.NORTH).getType() == Material.WOOL
							&& event.getClickedBlock()
									.getRelative(BlockFace.SOUTH).getType() == Material.WOOL) {
						Block[] blocks = new Block[] {
								block.getRelative(BlockFace.UP),
								block.getRelative(BlockFace.DOWN),
								block.getRelative(BlockFace.NORTH),
								block.getRelative(BlockFace.SOUTH),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.NORTH),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.SOUTH),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.NORTH),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.SOUTH) };
						boolean error2 = false;
						for (Block block2 : blocks) {
							if (!(block2.getType() == Material.WOOL && (block2
									.getData() == (byte) 5 || block2.getData() == (byte) 14))) {
								error2 = true;
							}
						}
						BlockFace face = BlockFace.SELF;
						if (block.getRelative(BlockFace.EAST).getType() == Material.WOOL) {
							face = BlockFace.EAST;
						}
						if (block.getRelative(BlockFace.WEST).getType() == Material.WOOL) {
							face = BlockFace.WEST;
						}
						if (!error2 && buttons.containsKey(block)
								&& face != BlockFace.SELF) {

							buttons.remove(block);
							for (Block block2 : blocks) {
								block2.setType(Material.WOOL);
								block2.setData((byte) 14);

							}
							for (Block block2 : blocks) {
								block2.getRelative(face).setType(
										Material.EMERALD_BLOCK);

							}

						} else if (!event.getPlayer().hasPermission(
								"portal.place")) {
							event.setCancelled(true);
						}
					}
				}

			}

		}

	}

	@SuppressWarnings("deprecation")
	@EventHandler
	public void blockPlace(BlockPlaceEvent event) {
		boolean cube = false;
		if (cubesPlayer.containsValue(event.getPlayer())) {
			
			for (Entry<Block, Player> entry : cubesPlayer.entrySet()) {
				if (event.getPlayer().equals(entry.getValue())
						&& cubesPlayerItem.get(entry.getKey()).getType() == event
								.getBlockPlaced().getType()
						&& cubesPlayerItem.get(entry.getKey()).getData()
								.getData() == event.getBlockPlaced().getData()) {

					cubesPlayer.remove(entry.getKey());
					cubesPlayerItem.remove(entry.getKey());
					cubesFallen.put(entry.getKey(), event.getBlockPlaced());
					cube = true;
					break;
				}
			}

		}
		Block blockUnder = event.getBlockPlaced().getRelative(BlockFace.DOWN);
		BlockFace[] blockfaces = new BlockFace[] { BlockFace.WEST,
				BlockFace.NORTH_WEST, BlockFace.NORTH, BlockFace.NORTH_EAST,
				BlockFace.EAST, BlockFace.SOUTH, BlockFace.SOUTH_WEST,
				BlockFace.SOUTH_EAST };

		if (blockUnder.getType() == Material.WOOL
				&& (blockUnder.getData() == (byte) 15
						|| blockUnder.getData() == (byte) 14 || blockUnder
						.getData() == (byte) 5)) {
			Block middle = blockUnder;
			// red wool - find closest black and check around
			if (blockUnder.getData() == (byte) 14) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}

			}
			// middle - already have relative
			if (blockUnder.getData() == (byte) 15) {
				if (blockUnder.getRelative(BlockFace.NORTH).getType() == Material.WOOL
						&& blockUnder.getRelative(BlockFace.NORTH).getData() == (byte) 14) {
					middle = blockUnder;

				} else if (blockUnder.getRelative(BlockFace.UP)
						.getRelative(BlockFace.NORTH).getType() == Material.WOOL
						&& blockUnder.getRelative(BlockFace.UP)
								.getRelative(BlockFace.NORTH).getData() == (byte) 14) {
					{
						middle = blockUnder.getRelative(BlockFace.UP);
					}

				}
			}
			// lime
			if (blockUnder.getData() == (byte) 5) {
				for (BlockFace f : blockfaces) {
					if (blockUnder.getRelative(f).getType() == Material.WOOL
							&& blockUnder.getRelative(f).getData() == (byte) 15) {
						middle = blockUnder.getRelative(f);

					}
				}

			}

			boolean error = false;
			for (BlockFace f : blockfaces) {
				if (!(middle.getRelative(f).getType() == Material.WOOL)) {
					error = true;
				}
			}

			if (buttonsToPlayer.containsValue(middle)) {
				Player p = event.getPlayer();
				for (Entry<Player, Block> entry : buttonsToPlayer.entrySet()) {
					if (middle.equals(entry.getValue())) {
						p = entry.getKey();
						break; // breaking because its one to one map
					}
				}
				buttonsToPlayer.remove(p);
				buttons.remove(middle);

			}
			if (!error && !buttons.containsKey(middle) && cube) {

				
				for (BlockFace f : blockfaces) {
					middle.getRelative(f).setType(Material.WOOL);
					middle.getRelative(f).setData((byte) 5);

				}
				Block under = middle.getRelative(BlockFace.DOWN);
				changeBtn(under, !buttons.containsKey(middle));
				buttons.put(middle, event.getBlock());
			} else {
				// vertical in wall block
				Block block = event.getBlockPlaced();
				if (event.getBlockPlaced().getRelative(BlockFace.DOWN)
						.getType() == Material.WOOL
						&& event.getBlockPlaced().getRelative(BlockFace.UP)
								.getType() == Material.WOOL) {
					if (event.getBlockPlaced().getRelative(BlockFace.WEST)
							.getType() == Material.WOOL
							&& event.getBlockPlaced()
									.getRelative(BlockFace.EAST).getType() == Material.WOOL) {
						Block[] blocks = new Block[] {
								block.getRelative(BlockFace.UP),
								block.getRelative(BlockFace.DOWN),
								block.getRelative(BlockFace.WEST),
								block.getRelative(BlockFace.EAST),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.WEST),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.EAST),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.WEST),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.EAST) };

						boolean error2 = false;
						for (Block block2 : blocks) {
							if (!(block2.getType() == Material.WOOL && (block2
									.getData() == (byte) 5 || block2.getData() == (byte) 14))) {
								error2 = true;
							}
						}
						BlockFace face = BlockFace.SELF;
						if (block.getRelative(BlockFace.NORTH).getType() == Material.WOOL) {
							face = BlockFace.NORTH;
						}
						if (block.getRelative(BlockFace.SOUTH).getType() == Material.WOOL) {
							face = BlockFace.SOUTH;
						}
						if (!error2 && !buttons.containsKey(block)
								&& face != BlockFace.SELF) {

							buttons.put(block, event.getBlock());
							for (Block block2 : blocks) {
								block2.setType(Material.WOOL);
								block2.setData((byte) 5);

							}
							for (Block block2 : blocks) {
								block2.getRelative(face).setType(
										Material.REDSTONE_BLOCK);

							}

						} else if (!event.getPlayer().hasPermission(
								"portal.place")) {
							event.setCancelled(true);
						}

					} else if (event.getBlockPlaced()
							.getRelative(BlockFace.NORTH).getType() == Material.WOOL
							&& event.getBlockPlaced()
									.getRelative(BlockFace.SOUTH).getType() == Material.WOOL) {
						Block[] blocks = new Block[] {
								block.getRelative(BlockFace.UP),
								block.getRelative(BlockFace.DOWN),
								block.getRelative(BlockFace.NORTH),
								block.getRelative(BlockFace.SOUTH),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.NORTH),
								block.getRelative(BlockFace.UP).getRelative(
										BlockFace.SOUTH),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.NORTH),
								block.getRelative(BlockFace.DOWN).getRelative(
										BlockFace.SOUTH) };

						boolean error2 = false;
						for (Block block2 : blocks) {
							if (!(block2.getType() == Material.WOOL && (block2
									.getData() == (byte) 5 || block2.getData() == (byte) 14))) {
								error2 = true;
							}
						}
						BlockFace face = BlockFace.SELF;
						if (block.getRelative(BlockFace.EAST).getType() == Material.WOOL) {
							face = BlockFace.EAST;
						}
						if (block.getRelative(BlockFace.WEST).getType() == Material.WOOL) {
							face = BlockFace.WEST;
						}
						if (!error2 && !buttons.containsKey(block)
								&& face != BlockFace.SELF) {

							buttons.put(block, event.getBlock());
							for (Block block2 : blocks) {
								block2.setType(Material.WOOL);
								block2.setData((byte) 5);

							}
							for (Block block2 : blocks) {
								block2.getRelative(face).setType(
										Material.REDSTONE_BLOCK);

							}

						} else if (!event.getPlayer().hasPermission(
								"portal.place")) {
							event.setCancelled(true);
						}
					}
				}

			}

		}
	}

	public List<Block> getNearbyBlocks(Location location, int Radius) {
		List<Block> Blocks = new ArrayList<Block>();

		for (int X = location.getBlockX() - Radius; X <= location.getBlockX()
				+ Radius; X++) {
			for (int Y = location.getBlockY() - Radius; Y <= location
					.getBlockY() + Radius; Y++) {
				for (int Z = location.getBlockZ() - Radius; Z <= location
						.getBlockZ() + Radius; Z++) {
					Block block = location.getWorld().getBlockAt(X, Y, Z);
					if (!block.isEmpty()) {
						Blocks.add(block);
					}
				}
			}
		}

		return Blocks;
	}

	@SuppressWarnings({ "deprecation" })
	@EventHandler
	public void onBlockPhysics(BlockPhysicsEvent event) {

		Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, new Runnable() {
			@Override
			public void run() {
				ArrayList<Block> BlockToRemove = new ArrayList<>();
				for (Block blk : wire) {
					if (!(blk.isBlockPowered() || blk
							.isBlockIndirectlyPowered())) {
						if (blk.getState().getData().getData() == DyeColor.LIME
								.getData()) {
							blk.setData(DyeColor.PINK.getData());
							new CheckWireTask(blk, blk, false).runTaskLater(
									plugin, 1L);
							return;
						} else if (blk.getState().getData().getData() == DyeColor.GREEN
								.getData()) {
							blk.setData(DyeColor.RED.getData());
							new CheckWireTask(blk, blk, false).runTaskLater(
									plugin, 1L);
							return;
						}
						BlockToRemove.add(blk);

					}
				}
				for (Block blk : BlockToRemove) {
					wire.remove(blk);
				}
				BlockToRemove.clear();
			}
		}, 2L);

		if (event.getBlock().getWorld().getName().toLowerCase()
				.contains("portal")) {
			for (Block blk : getNearbyBlocks(event.getBlock().getLocation(), 1)) {

				if (blk.getType() == Material.STAINED_CLAY
						&& (blk.isBlockPowered() || blk
								.isBlockIndirectlyPowered())) {

					if (blk.getState().getData().getData() == DyeColor.PINK
							.getData()) {
						blk.setData(DyeColor.LIME.getData());
						new CheckWireTask(blk, blk, true).runTaskLater(plugin,
								1L);
						wire.add(blk);
						return;
					} else if (blk.getState().getData().getData() == DyeColor.RED
							.getData()) {
						blk.setData(DyeColor.GREEN.getData());
						new CheckWireTask(blk, blk, true).runTaskLater(plugin,
								1L);
						wire.add(blk);
						return;
					}
				} else if (blk.getType() == Material.WALL_SIGN) {
					Sign s = (Sign) blk.getState();
					if (s.getLine(0).equals("hatch")) {

						org.bukkit.material.Sign sm = (org.bukkit.material.Sign) blk
								.getState().getData();
						Block attachedBlock = blk.getRelative(sm
								.getAttachedFace());
						Block hatchMiddle = null;
						try {
							hatchMiddle = attachedBlock.getRelative(
									BlockFace.DOWN,
									Integer.parseInt(s.getLine(2)) + 3);
						} catch (Exception e) {
							e.printStackTrace();
							return;
						}
						BlockFace[] blockfaces = new BlockFace[] {
								BlockFace.NORTH_EAST, BlockFace.EAST,
								BlockFace.SOUTH_EAST, BlockFace.SOUTH,
								BlockFace.SOUTH_WEST, BlockFace.WEST,
								BlockFace.NORTH_WEST, BlockFace.NORTH,
								BlockFace.SELF

						};

						if (blk.isBlockPowered()
								|| blk.isBlockIndirectlyPowered()) {

							for (int i = 0; i < blockfaces.length; i++) {

								hatches.put(
										new AnimateHatch(hatchMiddle
												.getRelative(blockfaces[i]),
												false, this).runTaskLater(
												plugin, 3L * i), blk);
							}

						} else {

							for (int i = 0; i < blockfaces.length; i++) {

								hatches.put(
										new AnimateHatch(hatchMiddle
												.getRelative(blockfaces[i]),
												true, this).runTaskLater(
												plugin, 3L * i), blk);
							}

						}
					} else if (s.getLine(0).equals("block")) {

						org.bukkit.material.Sign sm = (org.bukkit.material.Sign) blk
								.getState().getData();
						Block attachedBlock = blk.getRelative(sm
								.getAttachedFace());
						Block hatchMiddle = null;
						try {
							hatchMiddle = attachedBlock.getRelative(
									BlockFace.DOWN, 2);

							int id = 0;
							int data = 0;
							if (!s.getLine(1).isEmpty()) {
								try {
									id = Integer.parseInt(s.getLine(1).split(
											":")[0]);
									data = Integer.parseInt(s.getLine(1).split(
											":")[1]);
								} catch (NumberFormatException
										| IndexOutOfBoundsException nfe) {
									return;
								}
							}
							if (blk.isBlockPowered()
									|| blk.isBlockIndirectlyPowered()) {
								FallingBlock f = hatchMiddle.getWorld()
										.spawnFallingBlock(
												hatchMiddle.getLocation(), id,
												(byte) data);
								f.setDropItem(false);

								if (cubes.containsKey(hatchMiddle)) {
									cubes.get(hatchMiddle).remove();
									cubes.remove(hatchMiddle);
								} else if (FlyingBlocks
										.containsKey(hatchMiddle)) {
									FlyingBlocks.get(hatchMiddle).remove();
									FlyingBlocks.remove(hatchMiddle);

								} else if (cubesFallen.containsKey(hatchMiddle)) {

									cubesFallen.get(hatchMiddle).setType(
											Material.AIR);

									Block blockUnder = cubesFallen.get(
											hatchMiddle).getRelative(
											BlockFace.DOWN);
									cubesFallen.remove(hatchMiddle);
									BlockFace[] blockfaces = new BlockFace[] {
											BlockFace.WEST,
											BlockFace.NORTH_WEST,
											BlockFace.NORTH,
											BlockFace.NORTH_EAST,
											BlockFace.EAST, BlockFace.SOUTH,
											BlockFace.SOUTH_WEST,
											BlockFace.SOUTH_EAST };

									if (blockUnder.getType() == Material.WOOL) {
										Block middle = blockUnder;
										// red wool - find closest black and
										// check around
										if (blockUnder.getData() == (byte) 14) {
											for (BlockFace f2 : blockfaces) {
												if (blockUnder.getRelative(f2)
														.getType() == Material.WOOL
														&& blockUnder
																.getRelative(f2)
																.getData() == (byte) 15) {
													middle = blockUnder
															.getRelative(f2);

												}
											}

										}
										// middle - already have relative
										if (blockUnder.getData() == (byte) 15) {

											if (blockUnder.getRelative(
													BlockFace.NORTH).getType() == Material.WOOL
													&& blockUnder.getRelative(
															BlockFace.NORTH)
															.getData() == (byte) 5) {
												middle = blockUnder;
											} else if (blockUnder
													.getRelative(BlockFace.UP)
													.getRelative(
															BlockFace.NORTH)
													.getType() == Material.WOOL
													&& blockUnder
															.getRelative(
																	BlockFace.UP)
															.getRelative(
																	BlockFace.NORTH)
															.getData() == (byte) 5) {
												{
													middle = blockUnder
															.getRelative(BlockFace.UP);

												}

											}
										}
										// lime
										if (blockUnder.getData() == (byte) 5) {
											for (BlockFace f2 : blockfaces) {
												if (blockUnder.getRelative(f2)
														.getType() == Material.WOOL
														&& blockUnder
																.getRelative(f2)
																.getData() == (byte) 15) {
													middle = blockUnder
															.getRelative(f2);

												}
											}

										}

										boolean error = false;
										for (BlockFace f2 : blockfaces) {
											if (!(middle.getRelative(f2)
													.getType() == Material.WOOL)) {
												error = true;

											}
										}
										if (!error && buttons.containsKey(middle)) {

											for (BlockFace f2 : blockfaces) {
												middle.getRelative(f2).setType(
														Material.WOOL);
												middle.getRelative(f2).setData(
														(byte) 14);

											}
											Block under = middle
													.getRelative(BlockFace.DOWN);
											changeBtn(under, !buttons.containsKey(middle));
											buttons.remove(middle);
										}
									}

								}  else if (cubesPlayer.containsKey(hatchMiddle)) {

									// remove cubesPlayerItem.get(hatchMiddle)
									// from cubesPlayer.get(hatchMiddle)
									remove(cubesPlayer.get(hatchMiddle)
											.getInventory(), cubesPlayerItem
											.get(hatchMiddle).getType(), 1,
											cubesPlayerItem.get(hatchMiddle)
													.getData().getData());
									doInventoryUpdate(
											cubesPlayer.get(hatchMiddle),
											plugin);

									cubesPlayer.remove(hatchMiddle);

									cubesPlayerItem.remove(hatchMiddle);

								}
								cubes.put(hatchMiddle, f);
								cubesign.put(hatchMiddle, blk);
							} else {
								if (cubes.containsKey(hatchMiddle)) {
									cubes.get(hatchMiddle).remove();
									cubes.remove(hatchMiddle);
								} else if (cubesFallen.containsKey(hatchMiddle)) {
									cubesFallen.get(hatchMiddle).setType(
											Material.AIR);

									Block blockUnder = cubesFallen.get(
											hatchMiddle).getRelative(
											BlockFace.DOWN);
									cubesFallen.remove(hatchMiddle);
									BlockFace[] blockfaces = new BlockFace[] {
											BlockFace.WEST,
											BlockFace.NORTH_WEST,
											BlockFace.NORTH,
											BlockFace.NORTH_EAST,
											BlockFace.EAST, BlockFace.SOUTH,
											BlockFace.SOUTH_WEST,
											BlockFace.SOUTH_EAST };

									if (blockUnder.getType() == Material.WOOL) {
										Block middle = blockUnder;
										// red wool - find closest black and
										// check around
										if (blockUnder.getData() == (byte) 14) {
											for (BlockFace f : blockfaces) {
												if (blockUnder.getRelative(f)
														.getType() == Material.WOOL
														&& blockUnder
																.getRelative(f)
																.getData() == (byte) 15) {
													middle = blockUnder
															.getRelative(f);

												}
											}

										}
										// middle - already have relative
										if (blockUnder.getData() == (byte) 15) {

											if (blockUnder.getRelative(
													BlockFace.NORTH).getType() == Material.WOOL
													&& blockUnder.getRelative(
															BlockFace.NORTH)
															.getData() == (byte) 5) {
												middle = blockUnder;
											} else if (blockUnder
													.getRelative(BlockFace.UP)
													.getRelative(
															BlockFace.NORTH)
													.getType() == Material.WOOL
													&& blockUnder
															.getRelative(
																	BlockFace.UP)
															.getRelative(
																	BlockFace.NORTH)
															.getData() == (byte) 5) {
												{
													middle = blockUnder
															.getRelative(BlockFace.UP);

												}

											}
										}
										// lime
										if (blockUnder.getData() == (byte) 5) {
											for (BlockFace f : blockfaces) {
												if (blockUnder.getRelative(f)
														.getType() == Material.WOOL
														&& blockUnder
																.getRelative(f)
																.getData() == (byte) 15) {
													middle = blockUnder
															.getRelative(f);

												}
											}

										}
										boolean error = false;
										for (BlockFace f : blockfaces) {
											if (!(middle.getRelative(f)
													.getType() == Material.WOOL)) {
												error = true;
											}
										}
										if (!error && buttons.containsKey(middle)) {

											for (BlockFace f : blockfaces) {
												middle.getRelative(f).setType(
														Material.WOOL);
												middle.getRelative(f).setData(
														(byte) 14);

											}
											Block under = middle
													.getRelative(BlockFace.DOWN);
											changeBtn(under, !buttons.containsKey(middle));
											buttons.remove(middle);
										}
									}

								} else if (cubesPlayer.containsKey(hatchMiddle)) {

									// remove cubesPlayerItem.get(hatchMiddle)
									// from cubesPlayer.get(hatchMiddle)
									remove(cubesPlayer.get(hatchMiddle)
											.getInventory(), cubesPlayerItem
											.get(hatchMiddle).getType(), 1,
											cubesPlayerItem.get(hatchMiddle)
													.getData().getData());
									doInventoryUpdate(
											cubesPlayer.get(hatchMiddle),
											plugin);
									cubesPlayer.remove(hatchMiddle);

									cubesPlayerItem.remove(hatchMiddle);

								}

							}
						} catch (Exception e) {
							e.printStackTrace();
							return;
						}

					}
				}
			}
		}

	}

	public static void doInventoryUpdate(final Player player, Plugin plugin) {
		Bukkit.getScheduler().runTaskLater(plugin, new Runnable() {
			@SuppressWarnings("deprecation")
			@Override
			public void run() {
				player.updateInventory();
			}
		}, 1L);
	}

	@SuppressWarnings({ "deprecation" })
	@EventHandler
	public void onEntityChangeBlock(EntityChangeBlockEvent event) {
		if ((event.getEntity().getType().equals(EntityType.FALLING_BLOCK))
				&& cubes.containsValue((FallingBlock) event.getEntity())) {

			if (event.getBlock().getRelative(BlockFace.UP).getType() == Material.LAVA
					|| event.getBlock().getRelative(BlockFace.UP).getType() == Material.STATIONARY_LAVA) {
				if (cubes.containsValue((FallingBlock) event.getEntity())) {
					for (Entry<Block, FallingBlock> entry : cubes.entrySet()) {
						if (((FallingBlock) event.getEntity()).equals(entry
								.getValue())) {

							if (cubesign.get(entry.getKey()).isBlockPowered()
									|| cubesign.get(entry.getKey())
											.isBlockIndirectlyPowered()) {
								FallingBlock f = entry
										.getKey()
										.getWorld()
										.spawnFallingBlock(
												entry.getKey().getLocation(),
												entry.getValue().getBlockId(),
												(byte) entry.getValue()
														.getBlockData());
								f.setDropItem(false);
								event.getEntity().remove();
								cubes.remove(entry.getKey());
								cubes.put(entry.getKey(), f);
								event.setCancelled(true);
								return;
							}
						}
					}

				}
			}
			Block blockUnder = event.getBlock().getRelative(BlockFace.DOWN);
			BlockFace[] blockfaces = new BlockFace[] { BlockFace.WEST,
					BlockFace.NORTH_WEST, BlockFace.NORTH,
					BlockFace.NORTH_EAST, BlockFace.EAST, BlockFace.SOUTH,
					BlockFace.SOUTH_WEST, BlockFace.SOUTH_EAST };

			if (blockUnder.getType() == Material.WOOL
					&& (blockUnder.getData() == (byte) 15
							|| blockUnder.getData() == (byte) 14 || blockUnder
							.getData() == (byte) 5)) {

				Block middle = blockUnder;
				// red wool - find closest black and check around
				if (blockUnder.getData() == (byte) 14) {
					for (BlockFace f : blockfaces) {
						if (blockUnder.getRelative(f).getType() == Material.WOOL
								&& blockUnder.getRelative(f).getData() == (byte) 15) {
							middle = blockUnder.getRelative(f);

						}
					}

				}
				// middle - already have relative
				if (blockUnder.getData() == (byte) 15) {
					if (blockUnder.getRelative(BlockFace.NORTH).getType() == Material.WOOL
							&& blockUnder.getRelative(BlockFace.NORTH)
									.getData() == (byte) 14) {
						middle = blockUnder;

					} else if (blockUnder.getRelative(BlockFace.UP)
							.getRelative(BlockFace.NORTH).getType() == Material.WOOL
							&& blockUnder.getRelative(BlockFace.UP)
									.getRelative(BlockFace.NORTH).getData() == (byte) 14) {
						{
							middle = blockUnder.getRelative(BlockFace.UP);
						}

					}
				}
				// lime
				if (blockUnder.getData() == (byte) 5) {
					for (BlockFace f : blockfaces) {
						if (blockUnder.getRelative(f).getType() == Material.WOOL
								&& blockUnder.getRelative(f).getData() == (byte) 15) {
							middle = blockUnder.getRelative(f);

						}
					}

				}

				boolean error = false;
				for (BlockFace f : blockfaces) {
					if (!(middle.getRelative(f).getType() == Material.WOOL)) {
						error = true;
					}
				}

				if (!error && !buttons.containsKey(middle)) {

					
					for (BlockFace f : blockfaces) {
						middle.getRelative(f).setType(Material.WOOL);
						middle.getRelative(f).setData((byte) 5);

					}
					Block under = middle.getRelative(BlockFace.DOWN);
					changeBtn(under, !buttons.containsKey(middle));
					buttons.put(middle, event.getBlock());
				}
				for (Entry<Block, FallingBlock> entry : cubes.entrySet()) {
					if (((FallingBlock) event.getEntity()).equals(entry
							.getValue())) {
						cubesFallen.put(entry.getKey(), event.getBlock());
						cubes.remove(entry.getKey());
						return;
					}
				}
			} else if (blockUnder.getType() == Material.WOOL
					&& (blockUnder.getData() == (byte) 1)) {

				for (Entry<Block, FallingBlock> entry : cubes.entrySet()) {
					if (((FallingBlock) event.getEntity()).equals(entry
							.getValue())) {
						FlyingBlock fblock = new FlyingBlock(
								((FallingBlock) event.getEntity())
										.getMaterial(),
								((FallingBlock) event.getEntity())
										.getBlockData()) {

							@Override
							public void onTick() {
								Location l = this.getBukkitEntity()
										.getLocation();
								l.setY(l.getY() - this.getHeightOffset());
								Block Under = l.getBlock().getRelative(
										BlockFace.DOWN);
								if ((Under.getType() == Material.WOOL)
										&& (Under.getData() == (byte) 3)) {
									for (Entry<Block, FlyingBlock> entry : FlyingBlocks
											.entrySet()) {
										if (this.equals(entry.getValue())) {
											FallingBlock f = l
													.getWorld()
													.spawnFallingBlock(
															l,
															this.getMaterial().getId(),
															this.getMaterialData());
											f.setDropItem(false);
											f.setVelocity(this.getBukkitEntity().getVelocity().setY(1));
											
											cubes.put(entry.getKey(),
													f);
											FlyingBlocks.remove(entry.getKey());
										}}
								} else
								if (!(Under.getType() == Material.WOOL)
										|| !(Under.getData() == (byte) 1)) {
									
									for (Entry<Block, FlyingBlock> entry : FlyingBlocks
											.entrySet()) {
										if (this.equals(entry.getValue())) {

											l.getBlock().setType(
													this.getMaterial());
											l.getBlock().setData(
													this.getMaterialData());
											cubesFallen.put(entry.getKey(),
													l.getBlock());
											FlyingBlocks.remove(entry.getKey());
											Block blockUnder = l
													.getBlock()
													.getRelative(BlockFace.DOWN);
											BlockFace[] blockfaces = new BlockFace[] {
													BlockFace.WEST,
													BlockFace.NORTH_WEST,
													BlockFace.NORTH,
													BlockFace.NORTH_EAST,
													BlockFace.EAST,
													BlockFace.SOUTH,
													BlockFace.SOUTH_WEST,
													BlockFace.SOUTH_EAST };

											if (blockUnder.getType() == Material.WOOL
													&& (blockUnder.getData() == (byte) 15
															|| blockUnder
																	.getData() == (byte) 14 || blockUnder
															.getData() == (byte) 5)) {

												Block middle = blockUnder;
												// red wool - find closest black
												// and check around
												if (blockUnder.getData() == (byte) 14) {
													for (BlockFace f : blockfaces) {
														if (blockUnder
																.getRelative(f)
																.getType() == Material.WOOL
																&& blockUnder
																		.getRelative(
																				f)
																		.getData() == (byte) 15) {
															middle = blockUnder
																	.getRelative(f);

														}
													}

												}
												// middle - already have
												// relative
												if (blockUnder.getData() == (byte) 15) {
													if (blockUnder.getRelative(
															BlockFace.NORTH)
															.getType() == Material.WOOL
															&& blockUnder
																	.getRelative(
																			BlockFace.NORTH)
																	.getData() == (byte) 14) {
														middle = blockUnder;

													} else if (blockUnder
															.getRelative(
																	BlockFace.UP)
															.getRelative(
																	BlockFace.NORTH)
															.getType() == Material.WOOL
															&& blockUnder
																	.getRelative(
																			BlockFace.UP)
																	.getRelative(
																			BlockFace.NORTH)
																	.getData() == (byte) 14) {
														{
															middle = blockUnder
																	.getRelative(BlockFace.UP);
														}

													}
												}
												// lime
												if (blockUnder.getData() == (byte) 5) {
													for (BlockFace f : blockfaces) {
														if (blockUnder
																.getRelative(f)
																.getType() == Material.WOOL
																&& blockUnder
																		.getRelative(
																				f)
																		.getData() == (byte) 15) {
															middle = blockUnder
																	.getRelative(f);

														}
													}

												}

												boolean error = false;
												for (BlockFace f : blockfaces) {
													if (!(middle.getRelative(f)
															.getType() == Material.WOOL)) {
														error = true;
													}
												}

												if (!error
														&& !buttons
																.containsKey(middle)) {

													buttons.put(middle, l
															.getBlock());
													for (BlockFace f : blockfaces) {
														middle.getRelative(f)
																.setType(
																		Material.WOOL);
														middle.getRelative(f)
																.setData(
																		(byte) 5);

													}
													Block under = middle
															.getRelative(BlockFace.DOWN);
													under.getRelative(
															BlockFace.EAST)
															.getRelative(
																	BlockFace.EAST)
															.setType(
																	Material.REDSTONE_BLOCK);
													under.getRelative(
															BlockFace.WEST)
															.getRelative(
																	BlockFace.WEST)
															.setType(
																	Material.REDSTONE_BLOCK);
													under.getRelative(
															BlockFace.NORTH)
															.getRelative(
																	BlockFace.NORTH)
															.setType(
																	Material.REDSTONE_BLOCK);
													under.getRelative(
															BlockFace.SOUTH)
															.getRelative(
																	BlockFace.SOUTH)
															.setType(
																	Material.REDSTONE_BLOCK);

												}
											}
										}
									}

									this.remove();

								} else {

									this.setVelocity(this.getBukkitEntity()
											.getVelocity().multiply(1.05));

								}
							}

						};
						// spawn block
						fblock.spawn(event.getEntity().getLocation());
						fblock.setVelocity(event.getEntity().getVelocity());
						FlyingBlocks.put(entry.getKey(), fblock);
						event.getEntity().remove();
						event.setCancelled(true);
						cubes.remove(entry.getKey());
						return;
					}
				}

			} else {
				for (Entry<Block, FallingBlock> entry : cubes.entrySet()) {
					if (((FallingBlock) event.getEntity()).equals(entry
							.getValue())) {
						cubesFallen.put(entry.getKey(), event.getBlock());
						cubes.remove(entry.getKey());
						return;
					}
				}
			}
		}
	}
}
